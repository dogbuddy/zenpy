
######################################################################
#  Do not modify, these classes are autogenerated by gen_classes.py  #
######################################################################

import dateutil.parser

class BaseObject(object):
    def to_dict(self):
        copy_dict = self.__dict__.copy()
        for key in list(copy_dict.keys()):
            if copy_dict[key] is None or key == 'api':
                del copy_dict[key]
                continue

            if key.startswith('_'):
                copy_dict[key[1:]] = copy_dict[key]
                del copy_dict[key]
        return copy_dict

    def __repr__(self):
        if hasattr(self, 'id'):
            return "[%s(id=%s)]" % (self.__class__.__name__, self.id)
        else:
            return "[%s(id=None)]" % self.__class__.__name__

class Activity(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.actor = None
        self.created_at = None
        self.id = None
        self.title = None
        self.updated_at = None
        self.url = None
        self.user = None
        self.verb = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def updated(self):
        
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class Attachment(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: An array of Photo objects. Note that thumbnails do not have thumbnails.
        #:| Type: array
        #:| Read-only: yes
        self._thumbnails = None
        
        
        #:| Comment: The content type of the image. Example value: image/png
        #:| Type: string
        #:| Read-only: yes
        self.content_type = None
        
        
        #:| Comment: A full URL where the attachment image file can be downloaded
        #:| Type: string
        #:| Read-only: yes
        self.content_url = None
        
        
        #:| Comment: The name of the image file
        #:| Type: string
        #:| Read-only: yes
        self.file_name = None
        
        
        #:| Comment: Automatically assigned when created
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The size of the image file in bytes
        #:| Type: integer
        #:| Read-only: yes
        self.size = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def thumbnails(self):
        """
        |  Comment: An array of Photo objects. Note that thumbnails do not have thumbnails.
        """
        if self.api and self._thumbnails:
            return self.api._get_thumbnails(self._thumbnails)
    @thumbnails.setter
    def thumbnails(self, thumbnails):
            if thumbnails:
                self._thumbnails = thumbnails
    
    
class Audit(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._events = None
        self._metadata = None
        self._via = None
        self.author_id = None
        self.created_at = None
        self.id = None
        self.ticket_id = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def events(self):
        
        if self.api and self._events:
            return self.api._get_events(self._events)
    @events.setter
    def events(self, events):
            if events:
                self._events = events
    @property
    def metadata(self):
        
        if self.api and self._metadata:
            return self.api._get_metadata(self._metadata)
    @metadata.setter
    def metadata(self, metadata):
            if metadata:
                self._metadata = metadata
    @property
    def via(self):
        
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    @property
    def author(self):
        
        if self.api and self.author_id:
            return self.api._get_user(self.author_id)
    @author.setter
    def author(self, author):
            if author:
                self.author_id = author.id
    @property
    def created(self):
        
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def ticket(self):
        
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)
    @ticket.setter
    def ticket(self, ticket):
            if ticket:
                self.ticket_id = ticket.id
    
    
class Brand(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: Logo image for this brand
        #:| Mandatory: no
        #:| Type: :class:`Attachment`
        #:| Read-only: no
        self._logo = None
        
        
        #:| Comment: If the brand is set as active
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.active = None
        
        
        #:| Comment: The url of the brand
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.brand_url = None
        
        
        #:| Comment: The time the brand was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: Is the brand the default brand for this account
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.default = None
        
        
        #:| Comment: If the brand has a Help Center
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.has_help_center = None
        
        
        #:| Comment: The state of the Help Center: enabled, disabled, or restricted
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.help_center_state = None
        
        
        #:| Comment: The hostmapping to this brand, if any (only admins view this key)
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.host_mapping = None
        
        
        #:| Comment: Automatically assigned when the brand is created
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The name of the brand
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.name = None
        
        
        #:| Comment: The subdomain of the brand (only admins view this key)
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.subdomain = None
        
        
        #:| Comment: The time of the last update of the brand
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this brand
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def logo(self):
        """
        |  Comment: Logo image for this brand
        """
        if self.api and self._logo:
            return self.api._get_logo(self._logo)
    @logo.setter
    def logo(self, logo):
            if logo:
                self._logo = logo
    @property
    def created(self):
        """
        |  Comment: The time the brand was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the brand
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class CcEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._recipients = None
        self._via = None
        self.id = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):
        
        if self.api and self._recipients:
            return self.api._get_users(self._recipients)
    @recipients.setter
    def recipients(self, recipients):
            if recipients:
                self._recipients = recipients
    @property
    def via(self):
        
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    
    
class ChangeEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.field_name = None
        self.id = None
        self.previous_value = None
        self.type = None
        self.value = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Comment(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._attachments = None
        self._metadata = None
        self._via = None
        self.author_id = None
        self.body = None
        self.created_at = None
        self.id = None
        self.public = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachments(self):
        
        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)
    @attachments.setter
    def attachments(self, attachments):
            if attachments:
                self._attachments = attachments
    @property
    def metadata(self):
        
        if self.api and self._metadata:
            return self.api._get_metadata(self._metadata)
    @metadata.setter
    def metadata(self, metadata):
            if metadata:
                self._metadata = metadata
    @property
    def via(self):
        
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    @property
    def author(self):
        
        if self.api and self.author_id:
            return self.api._get_user(self.author_id)
    @author.setter
    def author(self, author):
            if author:
                self.author_id = author.id
    @property
    def created(self):
        
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    
    
class CommentPrivacyChangeEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.comment_id = None
        self.id = None
        self.public = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def comment(self):
        
        if self.api and self.comment_id:
            return self.api._get_comment(self.comment_id)
    @comment.setter
    def comment(self, comment):
            if comment:
                self.comment_id = comment.id
    
    
class CreateEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.field_name = None
        self.id = None
        self.type = None
        self.value = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class ErrorEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.id = None
        self.message = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class ExternalEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.body = None
        self.id = None
        self.resource = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class FacebookCommentEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._attachments = None
        self._data = None
        self.author_id = None
        self.body = None
        self.graph_object_id = None
        self.html_body = None
        self.id = None
        self.public = None
        self.trusted = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachments(self):
        
        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)
    @attachments.setter
    def attachments(self, attachments):
            if attachments:
                self._attachments = attachments
    @property
    def data(self):
        
        if self.api and self._data:
            return self.api._get_data(self._data)
    @data.setter
    def data(self, data):
            if data:
                self._data = data
    @property
    def author(self):
        
        if self.api and self.author_id:
            return self.api._get_user(self.author_id)
    @author.setter
    def author(self, author):
            if author:
                self.author_id = author.id
    
    
class FacebookEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._page = None
        self.body = None
        self.communication = None
        self.id = None
        self.ticket_via = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def page(self):
        
        if self.api and self._page:
            return self.api._get_page(self._page)
    @page.setter
    def page(self, page):
            if page:
                self._page = page
    
    
class Forum(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.access = None
        self.category_id = None
        self.created_at = None
        self.description = None
        self.forum_type = None
        self.id = None
        self.locale_id = None
        self.locked = None
        self.name = None
        self.organization_id = None
        self.position = None
        self.tags = None
        self.updated_at = None
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def category(self):
        
        if self.api and self.category_id:
            return self.api._get_category(self.category_id)
    @category.setter
    def category(self, category):
            if category:
                self.category_id = category.id
    @property
    def created(self):
        
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def organization(self):
        
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)
    @organization.setter
    def organization(self, organization):
            if organization:
                self.organization_id = organization.id
    @property
    def updated(self):
        
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class Group(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: The time the group was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: Deleted groups get marked as such
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.deleted = None
        
        
        #:| Comment: Automatically assigned when creating groups
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The name of the group
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.name = None
        
        
        #:| Comment: The time of the last update of the group
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this group
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Comment: The time the group was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the group
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class GroupMembership(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: The time the membership was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: If true, tickets assigned directly to the agent will assume this membership's group.
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.default = None
        
        
        #:| Comment: The id of a group
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: no
        self.group_id = None
        
        
        #:| Comment: Automatically assigned upon creation
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The time of the last update of the membership
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this record
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        
        #:| Comment: The id of an agent
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: no
        self.user_id = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Comment: The time the membership was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def group(self):
        """
        |  Comment: The id of a group
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)
    @group.setter
    def group(self, group):
            if group:
                self.group_id = group.id
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the membership
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    @property
    def user(self):
        """
        |  Comment: The id of an agent
        """
        if self.api and self.user_id:
            return self.api._get_user(self.user_id)
    @user.setter
    def user(self, user):
            if user:
                self.user_id = user.id
    
    
class JobStatus(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.id = None
        self.message = None
        self.progress = None
        self.results = None
        self.status = None
        self.total = None
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class LogmeinTranscriptEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.body = None
        self.id = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Metadata(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._custom = None
        self._system = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def custom(self):
        
        if self.api and self._custom:
            return self.api._get_custom(self._custom)
    @custom.setter
    def custom(self, custom):
            if custom:
                self._custom = custom
    @property
    def system(self):
        
        if self.api and self._system:
            return self.api._get_system(self._system)
    @system.setter
    def system(self, system):
            if system:
                self._system = system
    
    
class NotificationEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._recipients = None
        self._via = None
        self.body = None
        self.id = None
        self.subject = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):
        
        if self.api and self._recipients:
            return self.api._get_users(self._recipients)
    @recipients.setter
    def recipients(self, recipients):
            if recipients:
                self._recipients = recipients
    @property
    def via(self):
        
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    
    
class Organization(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: An array of domain names associated with this organization
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self._domain_names = None
        
        
        #:| Comment: Custom fields for this organization
        #:| Mandatory: no
        #:| Type: :class:`hash`
        #:| Read-only: no
        self._organization_fields = None
        
        
        #:| Comment: The time the organization was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: Any details obout the organization, such as the address
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.details = None
        
        
        #:| Comment: A unique external id to associate organizations to an external record
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.external_id = None
        
        
        #:| Comment: New tickets from users in this organization are automatically put in this group
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.group_id = None
        
        
        #:| Comment: Automatically assigned when the organization is created
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The name of the organization
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.name = None
        
        
        #:| Comment: Any notes you have about the organization
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.notes = None
        
        
        #:| Comment: End users in this organization are able to see each other's comments on tickets
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.shared_comments = None
        
        
        #:| Comment: End users in this organization are able to see each other's tickets
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.shared_tickets = None
        
        
        #:| Comment: The tags of the organization
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self.tags = None
        
        
        #:| Comment: The time of the last update of the organization
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this organization
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def organization_fields(self):
        """
        |  Comment: Custom fields for this organization
        """
        if self.api and self._organization_fields:
            return self.api._get_organization_fields(self._organization_fields)
    @organization_fields.setter
    def organization_fields(self, organization_fields):
            if organization_fields:
                self._organization_fields = organization_fields
    @property
    def created(self):
        """
        |  Comment: The time the organization was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def group(self):
        """
        |  Comment: New tickets from users in this organization are automatically put in this group
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)
    @group.setter
    def group(self, group):
            if group:
                self.group_id = group.id
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the organization
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class OrganizationActivityEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._recipients = None
        self._via = None
        self.body = None
        self.id = None
        self.subject = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):
        
        if self.api and self._recipients:
            return self.api._get_users(self._recipients)
    @recipients.setter
    def recipients(self, recipients):
            if recipients:
                self._recipients = recipients
    @property
    def via(self):
        
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    
    
class OrganizationField(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: If true, this field is available for use
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.active = None
        
        
        #:| Comment: The time the ticket field was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: User-defined description of this field's purpose
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.description = None
        
        
        #:| Comment: Automatically assigned upon creation
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders.
        #:| Mandatory: on create
        #:| Type: string
        #:| Read-only: no
        self.key = None
        
        
        #:| Comment: Ordering of the field relative to other fields
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.position = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_description = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_title = None
        
        
        #:| Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.regexp_for_validation = None
        
        
        #:| Comment: The title of the custom field
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.title = None
        
        
        #:| Comment: Type of the custom field: "checkbox", "date", "decimal", "dropdown", "integer", "regexp", "text", or "textarea"
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.type = None
        
        
        #:| Comment: The time of the last update of the ticket field
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The URL for this resource
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Comment: The time the ticket field was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the ticket field
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class OrganizationMembership(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: When this record was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: Denotes whether this is the default organization membership for the user
        #:| Mandatory: yes
        #:| Type: boolean
        #:| Read-only: no
        self.default = None
        
        
        #:| Comment: Automatically assigned when creating memberships
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The ID of the organization associated with this user, in this membership
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: yes
        self.organization_id = None
        
        
        #:| Comment: When this record last got updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this membership
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        
        #:| Comment: The ID of the user for whom this memberships belongs
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: yes
        self.user_id = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def organization(self):
        """
        |  Comment: The ID of the organization associated with this user, in this membership
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)
    @organization.setter
    def organization(self, organization):
            if organization:
                self.organization_id = organization.id
    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    @property
    def user(self):
        """
        |  Comment: The ID of the user for whom this memberships belongs
        """
        if self.api and self.user_id:
            return self.api._get_user(self.user_id)
    @user.setter
    def user(self, user):
            if user:
                self.user_id = user.id
    
    
class PushEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.id = None
        self.type = None
        self.value = None
        self.value_reference = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Request(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: The fields and entries for this request
        #:| Mandatory: no
        #:| Type: :class:`Array`
        #:| Read-only: no
        self._custom_fields = None
        self._fields = None
        
        
        #:| Comment: This object explains how the request was created
        #:| Mandatory: no
        #:| Type: :class:`Via`
        #:| Read-only: yes
        self._via = None
        
        
        #:| Comment: The id of the assignee if the field is visible to end users
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.assignee_id = None
        
        
        #:| Comment: If true, end user can mark request as solved.
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.can_be_solved_by_me = None
        
        
        #:| Comment: Who are currently CC'ed on the ticket
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self.collaborator_ids = None
        
        
        #:| Comment: When this record was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: The first comment on the request
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: yes
        self.description = None
        
        
        #:| Comment: When the task is due (only applies if the request is of type "task")
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: no
        self.due_at = None
        
        
        #:| Comment: Automatically assigned when creating requests
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The organization of the requester
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.organization_id = None
        
        
        #:| Comment: The priority of the request, "low", "normal", "high", "urgent"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.priority = None
        
        
        #:| Comment: The id of the requester
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.requester_id = None
        
        
        #:| Comment: The state of the request, "new", "open", "pending", "hold", "solved", "closed"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.status = None
        
        
        #:| Comment: The value of the subject field for this request if the subject field is visible to end users; a truncated version of the description otherwise
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.subject = None
        
        
        #:| Comment: The type of the request, "question", "incident", "problem", "task"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.type = None
        
        
        #:| Comment: When this record last got updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this request
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def custom_fields(self):
        """
        |  Comment: The fields and entries for this request
        """
        if self.api and self._custom_fields:
            return self.api._get_custom_fields(self._custom_fields)
    @custom_fields.setter
    def custom_fields(self, custom_fields):
            if custom_fields:
                self._custom_fields = custom_fields
    @property
    def fields(self):
        
        if self.api and self._fields:
            return self.api._get_fields(self._fields)
    @fields.setter
    def fields(self, fields):
            if fields:
                self._fields = fields
    @property
    def via(self):
        """
        |  Comment: This object explains how the request was created
        """
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    @property
    def assignee(self):
        """
        |  Comment: The id of the assignee if the field is visible to end users
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)
    @assignee.setter
    def assignee(self, assignee):
            if assignee:
                self.assignee_id = assignee.id
    @property
    def collaborators(self):
        """
        |  Comment: Who are currently CC'ed on the ticket
        """
        if self.api and self.collaborator_ids:
            return self.api._get_users(self.collaborator_ids)
    @collaborators.setter
    def collaborators(self, collaborators):
            if collaborators:
                self.collaborator_ids = [o.id for o in collaborators]
    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def due(self):
        """
        |  Comment: When the task is due (only applies if the request is of type "task")
        """
        if self.due_at:
            return dateutil.parser.parse(self.due_at)
    @due.setter
    def due(self, due):
            if due:
                self.due_at = due
    @property
    def organization(self):
        """
        |  Comment: The organization of the requester
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)
    @organization.setter
    def organization(self, organization):
            if organization:
                self.organization_id = organization.id
    @property
    def requester(self):
        """
        |  Comment: The id of the requester
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)
    @requester.setter
    def requester(self, requester):
            if requester:
                self.requester_id = requester.id
    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class Result(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._results = None
        self.count = None
        self.facets = None
        self.next_page = None
        self.prev_page = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def results(self):
        
        if self.api and self._results:
            return self.api._get_results(self._results)
    @results.setter
    def results(self, results):
            if results:
                self._results = results
    
    
class SatisfactionRating(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: The id of agent assigned to at the time of rating
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: yes
        self.assignee_id = None
        
        
        #:| Comment: The time the satisfaction rating got created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: The id of group assigned to at the time of rating
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: yes
        self.group_id = None
        
        
        #:| Comment: Automatically assigned upon creation
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The id of ticket requester submitting the rating
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: yes
        self.requester_id = None
        
        
        #:| Comment: The rating: "offered", "unoffered", "good" or "bad"
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: yes
        self.score = None
        
        
        #:| Comment: The id of ticket being rated
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: yes
        self.ticket_id = None
        
        
        #:| Comment: The time the satisfaction rating got updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this rating
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def assignee(self):
        """
        |  Comment: The id of agent assigned to at the time of rating
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)
    @assignee.setter
    def assignee(self, assignee):
            if assignee:
                self.assignee_id = assignee.id
    @property
    def created(self):
        """
        |  Comment: The time the satisfaction rating got created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def group(self):
        """
        |  Comment: The id of group assigned to at the time of rating
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)
    @group.setter
    def group(self, group):
            if group:
                self.group_id = group.id
    @property
    def requester(self):
        """
        |  Comment: The id of ticket requester submitting the rating
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)
    @requester.setter
    def requester(self, requester):
            if requester:
                self.requester_id = requester.id
    @property
    def ticket(self):
        """
        |  Comment: The id of ticket being rated
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)
    @ticket.setter
    def ticket(self, ticket):
            if ticket:
                self.ticket_id = ticket.id
    @property
    def updated(self):
        """
        |  Comment: The time the satisfaction rating got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class SatisfactionRatingEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.assignee_id = None
        self.body = None
        self.id = None
        self.score = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def assignee(self):
        
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)
    @assignee.setter
    def assignee(self, assignee):
            if assignee:
                self.assignee_id = assignee.id
    
    
class Source(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._from_ = None
        self._to = None
        self.rel = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def from_(self):
        
        if self.api and self._from_:
            return self.api._get_from_(self._from_)
    @from_.setter
    def from_(self, from_):
            if from_:
                self._from_ = from_
    
    
class Status(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.action = None
        self.errors = None
        self.id = None
        self.status = None
        self.success = None
        self.title = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class SuspendedTicket(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: The author id (if available), name and email
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._author = None
        
        
        #:| Comment: This object explains how the ticket was created
        #:| Mandatory: no
        #:| Type: :class:`Via`
        #:| Read-only: yes
        self._via = None
        
        
        #:| Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.brand_id = None
        
        
        #:| Comment: Why the ticket was suspended
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.cause = None
        
        
        #:| Comment: The content that was flagged
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.content = None
        
        
        #:| Comment: When this record was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: Automatically assigned
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The original recipient e-mail address of the ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.recipient = None
        
        
        #:| Comment: The value of the subject field for this ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.subject = None
        
        
        #:| Comment: The ticket ID this suspended email is associated with, if available
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.ticket_id = None
        
        
        #:| Comment: When this record last got updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def via(self):
        """
        |  Comment: This object explains how the ticket was created
        """
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    @property
    def brand(self):
        """
        |  Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        """
        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)
    @brand.setter
    def brand(self, brand):
            if brand:
                self.brand_id = brand.id
    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def ticket(self):
        """
        |  Comment: The ticket ID this suspended email is associated with, if available
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)
    @ticket.setter
    def ticket(self, ticket):
            if ticket:
                self.ticket_id = ticket.id
    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class System(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.client = None
        self.ip_address = None
        self.latitude = None
        self.location = None
        self.longitude = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Tag(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.count = None
        self.name = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Thumbnail(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.content_type = None
        self.content_url = None
        self.file_name = None
        self.id = None
        self.size = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Ticket(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: The custom fields of the ticket
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self._custom_fields = None
        self._fields = None
        
        
        #:| Comment: The satisfaction rating of the ticket, if it exists, or the state of satisfaction, 'offered' or 'unoffered'
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._satisfaction_rating = None
        
        
        #:| Comment: This object explains how the ticket was created
        #:| Mandatory: no
        #:| Type: :class:`Via`
        #:| Read-only: yes
        self._via = None
        
        
        #:| Comment: What agent is currently assigned to the ticket
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.assignee_id = None
        
        
        #:| Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.brand_id = None
        
        
        #:| Comment: Who are currently CC'ed on the ticket
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self.collaborator_ids = None
        
        
        #:| Comment: When this record was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: The first comment on the ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.description = None
        
        
        #:| Comment: If this is a ticket of type "task" it has a due date.  Due date format uses ISO 8601 format.
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: no
        self.due_at = None
        
        
        #:| Comment: An id you can use to link Zendesk tickets to local records
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.external_id = None
        
        
        #:| Comment: The topic this ticket originated from, if any
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.forum_topic_id = None
        
        
        #:| Comment: The group this ticket is assigned to
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.group_id = None
        
        
        #:| Comment: Is true of this ticket has been marked as a problem, false otherwise
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.has_incidents = None
        
        
        #:| Comment: Automatically assigned when creating tickets
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The organization of the requester
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.organization_id = None
        
        
        #:| Comment: Priority, defines the urgency with which the ticket should be addressed: "urgent", "high", "normal", "low"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.priority = None
        
        
        #:| Comment: The problem this incident is linked to, if any
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.problem_id = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "subject" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_subject = None
        
        
        #:| Comment: The original recipient e-mail address of the ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.recipient = None
        
        
        #:| Comment: The user who requested this ticket
        #:| Mandatory: yes
        #:| Type: integer
        #:| Read-only: no
        self.requester_id = None
        
        
        #:| Comment: The ids of the sharing agreements used for this ticket
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: yes
        self.sharing_agreement_ids = None
        
        
        #:| Comment: The state of the ticket, "new", "open", "pending", "hold", "solved", "closed"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.status = None
        
        
        #:| Comment: The value of the subject field for this ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.subject = None
        
        
        #:| Comment: The user who submitted the ticket; The submitter always becomes the author of the first comment on the ticket.
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.submitter_id = None
        
        
        #:| Comment: The array of tags applied to this ticket
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self.tags = None
        
        
        #:| Comment: The id of the ticket form to render for this ticket - only applicable for enterprise accounts
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.ticket_form_id = None
        
        
        #:| Comment: The type of this ticket, i.e. "problem", "incident", "question" or "task"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.type = None
        
        
        #:| Comment: When this record last got updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The API url of this ticket
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def custom_fields(self):
        """
        |  Comment: The custom fields of the ticket
        """
        if self.api and self._custom_fields:
            return self.api._get_custom_fields(self._custom_fields)
    @custom_fields.setter
    def custom_fields(self, custom_fields):
            if custom_fields:
                self._custom_fields = custom_fields
    @property
    def fields(self):
        
        if self.api and self._fields:
            return self.api._get_fields(self._fields)
    @fields.setter
    def fields(self, fields):
            if fields:
                self._fields = fields
    @property
    def satisfaction_rating(self):
        """
        |  Comment: The satisfaction rating of the ticket, if it exists, or the state of satisfaction, 'offered' or 'unoffered'
        """
        if self.api and self._satisfaction_rating:
            return self.api._get_satisfaction_rating(self._satisfaction_rating)
    @satisfaction_rating.setter
    def satisfaction_rating(self, satisfaction_rating):
            if satisfaction_rating:
                self._satisfaction_rating = satisfaction_rating
    @property
    def via(self):
        """
        |  Comment: This object explains how the ticket was created
        """
        if self.api and self._via:
            return self.api._get_via(self._via)
    @via.setter
    def via(self, via):
            if via:
                self._via = via
    @property
    def assignee(self):
        """
        |  Comment: What agent is currently assigned to the ticket
        """
        if self.api and self.assignee_id:
            return self.api._get_user(self.assignee_id)
    @assignee.setter
    def assignee(self, assignee):
            if assignee:
                self.assignee_id = assignee.id
    @property
    def brand(self):
        """
        |  Comment: The id of the brand this ticket is associated with - only applicable for enterprise accounts
        """
        if self.api and self.brand_id:
            return self.api._get_brand(self.brand_id)
    @brand.setter
    def brand(self, brand):
            if brand:
                self.brand_id = brand.id
    @property
    def collaborators(self):
        """
        |  Comment: Who are currently CC'ed on the ticket
        """
        if self.api and self.collaborator_ids:
            return self.api._get_users(self.collaborator_ids)
    @collaborators.setter
    def collaborators(self, collaborators):
            if collaborators:
                self.collaborator_ids = [o.id for o in collaborators]
    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def due(self):
        """
        |  Comment: If this is a ticket of type "task" it has a due date.  Due date format uses ISO 8601 format.
        """
        if self.due_at:
            return dateutil.parser.parse(self.due_at)
    @due.setter
    def due(self, due):
            if due:
                self.due_at = due
    @property
    def forum_topic(self):
        """
        |  Comment: The topic this ticket originated from, if any
        """
        if self.api and self.forum_topic_id:
            return self.api._get_topic(self.forum_topic_id)
    @forum_topic.setter
    def forum_topic(self, forum_topic):
            if forum_topic:
                self.forum_topic_id = forum_topic.id
    @property
    def group(self):
        """
        |  Comment: The group this ticket is assigned to
        """
        if self.api and self.group_id:
            return self.api._get_group(self.group_id)
    @group.setter
    def group(self, group):
            if group:
                self.group_id = group.id
    @property
    def organization(self):
        """
        |  Comment: The organization of the requester
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)
    @organization.setter
    def organization(self, organization):
            if organization:
                self.organization_id = organization.id
    @property
    def problem(self):
        """
        |  Comment: The problem this incident is linked to, if any
        """
        if self.api and self.problem_id:
            return self.api._get_problem(self.problem_id)
    @problem.setter
    def problem(self, problem):
            if problem:
                self.problem_id = problem.id
    @property
    def requester(self):
        """
        |  Comment: The user who requested this ticket
        """
        if self.api and self.requester_id:
            return self.api._get_user(self.requester_id)
    @requester.setter
    def requester(self, requester):
            if requester:
                self.requester_id = requester.id
    @property
    def sharing_agreements(self):
        """
        |  Comment: The ids of the sharing agreements used for this ticket
        """
        if self.api and self.sharing_agreement_ids:
            return self.api._get_sharing_agreements(self.sharing_agreement_ids)
    @sharing_agreements.setter
    def sharing_agreements(self, sharing_agreements):
            if sharing_agreements:
                self.sharing_agreement_ids = [o.id for o in sharing_agreements]
    @property
    def submitter(self):
        """
        |  Comment: The user who submitted the ticket; The submitter always becomes the author of the first comment on the ticket.
        """
        if self.api and self.submitter_id:
            return self.api._get_user(self.submitter_id)
    @submitter.setter
    def submitter(self, submitter):
            if submitter:
                self.submitter_id = submitter.id
    @property
    def ticket_form(self):
        """
        |  Comment: The id of the ticket form to render for this ticket - only applicable for enterprise accounts
        """
        if self.api and self.ticket_form_id:
            return self.api._get_ticket_form(self.ticket_form_id)
    @ticket_form.setter
    def ticket_form(self, ticket_form):
            if ticket_form:
                self.ticket_form_id = ticket_form.id
    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class TicketAudit(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.audit = None
        self.ticket = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class TicketEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._child_events = None
        self.id = None
        self.ticket_id = None
        self.timestamp = None
        self.updater_id = None
        self.via = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def child_events(self):
        
        if self.api and self._child_events:
            return self.api._get_child_events(self._child_events)
    @child_events.setter
    def child_events(self, child_events):
            if child_events:
                self._child_events = child_events
    @property
    def ticket(self):
        
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)
    @ticket.setter
    def ticket(self, ticket):
            if ticket:
                self.ticket_id = ticket.id
    @property
    def updater(self):
        
        if self.api and self.updater_id:
            return self.api._get_user(self.updater_id)
    @updater.setter
    def updater(self, updater):
            if updater:
                self.updater_id = updater.id
    
    
class TicketField(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: Whether this field is available
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.active = None
        
        
        #:| Comment: If this field should be shown to agents by default or be hidden alongside infrequently used fields. Classic interface only
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.collapsed_for_agents = None
        
        
        #:| Comment: The time the ticket field was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: The description of the purpose of this ticket field, shown to users
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.description = None
        
        
        #:| Comment: Whether this field is editable by end users
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.editable_in_portal = None
        
        
        #:| Comment: Automatically assigned upon creation
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: A relative position for the ticket fields, determines the order of ticket fields on a ticket
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.position = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_description = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_title = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "title_in_portal" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_title_in_portal = None
        
        
        #:| Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.regexp_for_validation = None
        
        
        #:| Comment: If it's required for this field to have a value when updated by agents
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.required = None
        
        
        #:| Comment: If it's required for this field to have a value when updated by end users
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.required_in_portal = None
        
        
        #:| Comment: A tag value to set for checkbox fields when checked
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.tag = None
        
        
        #:| Comment: The title of the ticket field
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.title = None
        
        
        #:| Comment: The title of the ticket field when shown to end users
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.title_in_portal = None
        
        
        #:| Comment: The type of the ticket field: "checkbox", "date", "decimal", "integer", "regexp", "tagger", "text", or "textarea"
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.type = None
        
        
        #:| Comment: The time of the last update of the ticket field
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The URL for this resource
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        
        #:| Comment: Whether this field is available to end users
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.visible_in_portal = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Comment: The time the ticket field was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the ticket field
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class TicketForm(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: If the form is set as active
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.active = None
        self.created_at = None
        
        
        #:| Comment: Is the form the default form for this account
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.default = None
        
        
        #:| Comment: The name of the form that is displayed to an end user
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.display_name = None
        
        
        #:| Comment: Is the form visible to the end user
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.end_user_visible = None
        self.id = None
        
        
        #:| Comment: Is the form available for use in all brands on this account
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.in_all_brands = None
        self.in_all_organizations = None
        
        
        #:| Comment: The name of the form
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.name = None
        
        
        #:| Comment: The position of this form among other forms in the account, i.e. dropdown
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.position = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "display_name" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_display_name = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "name" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_name = None
        
        
        #:| Comment: ids of all brands that this ticket form is restricted to
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: yes
        self.restricted_brand_ids = None
        self.restricted_organization_ids = None
        
        
        #:| Comment: ids of all ticket fields which are in this ticket form
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self.ticket_field_ids = None
        self.updated_at = None
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def restricted_brands(self):
        """
        |  Comment: ids of all brands that this ticket form is restricted to
        """
        if self.api and self.restricted_brand_ids:
            return self.api._get_restricted_brands(self.restricted_brand_ids)
    @restricted_brands.setter
    def restricted_brands(self, restricted_brands):
            if restricted_brands:
                self.restricted_brand_ids = [o.id for o in restricted_brands]
    @property
    def restricted_organizations(self):
        
        if self.api and self.restricted_organization_ids:
            return self.api._get_restricted_organizations(self.restricted_organization_ids)
    @restricted_organizations.setter
    def restricted_organizations(self, restricted_organizations):
            if restricted_organizations:
                self.restricted_organization_ids = [o.id for o in restricted_organizations]
    @property
    def ticket_fields(self):
        """
        |  Comment: ids of all ticket fields which are in this ticket form
        """
        if self.api and self.ticket_field_ids:
            return self.api._get_ticket_fields(self.ticket_field_ids)
    @ticket_fields.setter
    def ticket_fields(self, ticket_fields):
            if ticket_fields:
                self.ticket_field_ids = [o.id for o in ticket_fields]
    @property
    def updated(self):
        
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class TicketMetric(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: Number of minutes the agent spent waiting inside and out of business hours
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._agent_wait_time_in_minutes = None
        
        
        #:| Comment: Number of minutes to the first resolution time inside and out of business hours
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._first_resolution_time_in_minutes = None
        
        
        #:| Comment: Number of minutes to the full resolution inside and out of business hours
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._full_resolution_time_in_minutes = None
        self._on_hold_time_in_minutes = None
        
        
        #:| Comment: Number of minutes to the first reply inside and out of business hours
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._reply_time_in_minutes = None
        
        
        #:| Comment: Number of minutes the requester spent waiting inside and out of business hours
        #:| Mandatory: no
        #:| Type: object
        #:| Read-only: yes
        self._requester_wait_time_in_minutes = None
        
        
        #:| Comment: When the ticket was last assigned
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.assigned_at = None
        
        
        #:| Comment: Number of assignees this ticket had
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.assignee_stations = None
        
        
        #:| Comment: When the assignee last updated the ticket
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.assignee_updated_at = None
        
        
        #:| Comment: When this record was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: Number of groups this ticket passed through
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.group_stations = None
        
        
        #:| Comment: Automatically assigned
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: When the ticket was initially assigned
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.initially_assigned_at = None
        
        
        #:| Comment: When the latest comment was added
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.latest_comment_added_at = None
        
        
        #:| Comment: Total number of times the ticket was reopened
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.reopens = None
        
        
        #:| Comment: Total number of times ticket was replied to
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.replies = None
        
        
        #:| Comment: When the requester last updated the ticket
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.requester_updated_at = None
        
        
        #:| Comment: When the ticket was solved
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.solved_at = None
        
        
        #:| Comment: When the status was last updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.status_updated_at = None
        
        
        #:| Comment: Id of the associated ticket
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.ticket_id = None
        
        
        #:| Comment: When this record last got updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def agent_wait_time_in_minutes(self):
        """
        |  Comment: Number of minutes the agent spent waiting inside and out of business hours
        """
        if self.api and self._agent_wait_time_in_minutes:
            return self.api._get_ticket_metric_item(self._agent_wait_time_in_minutes)
    @agent_wait_time_in_minutes.setter
    def agent_wait_time_in_minutes(self, agent_wait_time_in_minutes):
            if agent_wait_time_in_minutes:
                self._agent_wait_time_in_minutes = agent_wait_time_in_minutes
    @property
    def first_resolution_time_in_minutes(self):
        """
        |  Comment: Number of minutes to the first resolution time inside and out of business hours
        """
        if self.api and self._first_resolution_time_in_minutes:
            return self.api._get_ticket_metric_item(self._first_resolution_time_in_minutes)
    @first_resolution_time_in_minutes.setter
    def first_resolution_time_in_minutes(self, first_resolution_time_in_minutes):
            if first_resolution_time_in_minutes:
                self._first_resolution_time_in_minutes = first_resolution_time_in_minutes
    @property
    def full_resolution_time_in_minutes(self):
        """
        |  Comment: Number of minutes to the full resolution inside and out of business hours
        """
        if self.api and self._full_resolution_time_in_minutes:
            return self.api._get_ticket_metric_item(self._full_resolution_time_in_minutes)
    @full_resolution_time_in_minutes.setter
    def full_resolution_time_in_minutes(self, full_resolution_time_in_minutes):
            if full_resolution_time_in_minutes:
                self._full_resolution_time_in_minutes = full_resolution_time_in_minutes
    @property
    def on_hold_time_in_minutes(self):
        
        if self.api and self._on_hold_time_in_minutes:
            return self.api._get_ticket_metric_item(self._on_hold_time_in_minutes)
    @on_hold_time_in_minutes.setter
    def on_hold_time_in_minutes(self, on_hold_time_in_minutes):
            if on_hold_time_in_minutes:
                self._on_hold_time_in_minutes = on_hold_time_in_minutes
    @property
    def reply_time_in_minutes(self):
        """
        |  Comment: Number of minutes to the first reply inside and out of business hours
        """
        if self.api and self._reply_time_in_minutes:
            return self.api._get_ticket_metric_item(self._reply_time_in_minutes)
    @reply_time_in_minutes.setter
    def reply_time_in_minutes(self, reply_time_in_minutes):
            if reply_time_in_minutes:
                self._reply_time_in_minutes = reply_time_in_minutes
    @property
    def requester_wait_time_in_minutes(self):
        """
        |  Comment: Number of minutes the requester spent waiting inside and out of business hours
        """
        if self.api and self._requester_wait_time_in_minutes:
            return self.api._get_ticket_metric_item(self._requester_wait_time_in_minutes)
    @requester_wait_time_in_minutes.setter
    def requester_wait_time_in_minutes(self, requester_wait_time_in_minutes):
            if requester_wait_time_in_minutes:
                self._requester_wait_time_in_minutes = requester_wait_time_in_minutes
    @property
    def assigned(self):
        """
        |  Comment: When the ticket was last assigned
        """
        if self.assigned_at:
            return dateutil.parser.parse(self.assigned_at)
    @assigned.setter
    def assigned(self, assigned):
            if assigned:
                self.assigned_at = assigned
    @property
    def assignee_updated(self):
        """
        |  Comment: When the assignee last updated the ticket
        """
        if self.assignee_updated_at:
            return dateutil.parser.parse(self.assignee_updated_at)
    @assignee_updated.setter
    def assignee_updated(self, assignee_updated):
            if assignee_updated:
                self.assignee_updated_at = assignee_updated
    @property
    def created(self):
        """
        |  Comment: When this record was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def initially_assigned(self):
        """
        |  Comment: When the ticket was initially assigned
        """
        if self.initially_assigned_at:
            return dateutil.parser.parse(self.initially_assigned_at)
    @initially_assigned.setter
    def initially_assigned(self, initially_assigned):
            if initially_assigned:
                self.initially_assigned_at = initially_assigned
    @property
    def latest_comment_added(self):
        """
        |  Comment: When the latest comment was added
        """
        if self.latest_comment_added_at:
            return dateutil.parser.parse(self.latest_comment_added_at)
    @latest_comment_added.setter
    def latest_comment_added(self, latest_comment_added):
            if latest_comment_added:
                self.latest_comment_added_at = latest_comment_added
    @property
    def requester_updated(self):
        """
        |  Comment: When the requester last updated the ticket
        """
        if self.requester_updated_at:
            return dateutil.parser.parse(self.requester_updated_at)
    @requester_updated.setter
    def requester_updated(self, requester_updated):
            if requester_updated:
                self.requester_updated_at = requester_updated
    @property
    def solved(self):
        """
        |  Comment: When the ticket was solved
        """
        if self.solved_at:
            return dateutil.parser.parse(self.solved_at)
    @solved.setter
    def solved(self, solved):
            if solved:
                self.solved_at = solved
    @property
    def status_updated(self):
        """
        |  Comment: When the status was last updated
        """
        if self.status_updated_at:
            return dateutil.parser.parse(self.status_updated_at)
    @status_updated.setter
    def status_updated(self, status_updated):
            if status_updated:
                self.status_updated_at = status_updated
    @property
    def ticket(self):
        """
        |  Comment: Id of the associated ticket
        """
        if self.api and self.ticket_id:
            return self.api._get_ticket(self.ticket_id)
    @ticket.setter
    def ticket(self, ticket):
            if ticket:
                self.ticket_id = ticket.id
    @property
    def updated(self):
        """
        |  Comment: When this record last got updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class TicketMetricItem(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.business = None
        self.calendar = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class TicketSharingEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.action = None
        self.agreement_id = None
        self.id = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def agreement(self):
        
        if self.api and self.agreement_id:
            return self.api._get_agreement(self.agreement_id)
    @agreement.setter
    def agreement(self, agreement):
            if agreement:
                self.agreement_id = agreement.id
    
    
class Topic(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._search_phrases = None
        self.body = None
        self.created_at = None
        self.forum_id = None
        self.id = None
        self.locked = None
        self.pinned = None
        self.position = None
        self.submitter_id = None
        self.tags = None
        self.title = None
        self.topic_type = None
        self.updated_at = None
        self.updater_id = None
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def search_phrases(self):
        
        if self.api and self._search_phrases:
            return self.api._get_search_phrases(self._search_phrases)
    @search_phrases.setter
    def search_phrases(self, search_phrases):
            if search_phrases:
                self._search_phrases = search_phrases
    @property
    def created(self):
        
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def forum(self):
        
        if self.api and self.forum_id:
            return self.api._get_forum(self.forum_id)
    @forum.setter
    def forum(self, forum):
            if forum:
                self.forum_id = forum.id
    @property
    def submitter(self):
        
        if self.api and self.submitter_id:
            return self.api._get_user(self.submitter_id)
    @submitter.setter
    def submitter(self, submitter):
            if submitter:
                self.submitter_id = submitter.id
    @property
    def updated(self):
        
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    @property
    def updater(self):
        
        if self.api and self.updater_id:
            return self.api._get_user(self.updater_id)
    @updater.setter
    def updater(self, updater):
            if updater:
                self.updater_id = updater.id
    
    
class TweetEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._recipients = None
        self.body = None
        self.direct_message = None
        self.id = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def recipients(self):
        
        if self.api and self._recipients:
            return self.api._get_users(self._recipients)
    @recipients.setter
    def recipients(self, recipients):
            if recipients:
                self._recipients = recipients
    
    
class User(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: Custom fields for the user
        #:| Mandatory: no
        #:| Type: :class:`hash`
        #:| Read-only: no
        self._user_fields = None
        
        
        #:| Comment: false if the user has been deleted
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.active = None
        
        
        #:| Comment: An alias displayed to end users
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.alias = None
        self.chat_only = None
        
        
        #:| Comment: The time the user was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: A custom role if the user is an agent on the Enterprise plan
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.custom_role_id = None
        
        
        #:| Comment: Any details you want to store about the user, such as an address
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.details = None
        
        
        #:| Comment: The user's primary email address
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.email = None
        
        
        #:| Comment: A unique id you can specify for the user
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.external_id = None
        
        
        #:| Comment: Automatically assigned when the user is created
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: The last time the user signed in to Zendesk
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.last_login_at = None
        
        
        #:| Comment: The user's locale
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.locale = None
        
        
        #:| Comment: The user's language identifier
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.locale_id = None
        
        
        #:| Comment: Designates whether the user has forum moderation capabilities
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.moderator = None
        
        
        #:| Comment: The user's name
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.name = None
        
        
        #:| Comment: Any notes you want to store about the user
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.notes = None
        
        
        #:| Comment: true if the user can only create private comments
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.only_private_comments = None
        
        
        #:| Comment: The id of the organization the user is associated with
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.organization_id = None
        
        
        #:| Comment: The user's primary phone number
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.phone = None
        
        
        #:| Comment: The user's profile picture represented as an Attachment object
        #:| Mandatory: no
        #:| Type: :class:`Attachment`
        #:| Read-only: no
        self.photo = None
        
        
        #:| Comment: If the agent has any restrictions; false for admins and unrestricted agents, true for other agents
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.restricted_agent = None
        
        
        #:| Comment: The user's role. Possible values are "end-user", "agent", or "admin"
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.role = None
        
        
        #:| Comment: If the user is shared from a different Zendesk. Ticket sharing accounts only
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.shared = None
        
        
        #:| Comment: If the user is a shared agent from a different Zendesk. Ticket sharing accounts only
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.shared_agent = None
        
        
        #:| Comment: The user's signature. Only agents and admins can have signatures
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.signature = None
        
        
        #:| Comment: If the agent is suspended. Tickets from suspended users are also suspended, and these users cannot sign in to the end user portal
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.suspended = None
        
        
        #:| Comment: The user's tags. Only present if your account has user tagging enabled
        #:| Mandatory: no
        #:| Type: array
        #:| Read-only: no
        self.tags = None
        
        
        #:| Comment: Specifies which tickets the user has access to. Possible values are: "organization", "groups", "assigned", "requested", null
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.ticket_restriction = None
        
        
        #:| Comment: The user's time zone. See Time Zone below
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.time_zone = None
        
        
        #:| Comment: If two factor authentication is enabled.
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: yes
        self.two_factor_auth_enabled = None
        
        
        #:| Comment: The time the user was last updated
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The user's API url
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        
        #:| Comment: If the user's identity has been verified or not
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.verified = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def user_fields(self):
        """
        |  Comment: Custom fields for the user
        """
        if self.api and self._user_fields:
            return self.api._get_user_fields(self._user_fields)
    @user_fields.setter
    def user_fields(self, user_fields):
            if user_fields:
                self._user_fields = user_fields
    @property
    def created(self):
        """
        |  Comment: The time the user was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def custom_role(self):
        """
        |  Comment: A custom role if the user is an agent on the Enterprise plan
        """
        if self.api and self.custom_role_id:
            return self.api._get_custom_role(self.custom_role_id)
    @custom_role.setter
    def custom_role(self, custom_role):
            if custom_role:
                self.custom_role_id = custom_role.id
    @property
    def last_login(self):
        """
        |  Comment: The last time the user signed in to Zendesk
        """
        if self.last_login_at:
            return dateutil.parser.parse(self.last_login_at)
    @last_login.setter
    def last_login(self, last_login):
            if last_login:
                self.last_login_at = last_login
    @property
    def organization(self):
        """
        |  Comment: The id of the organization the user is associated with
        """
        if self.api and self.organization_id:
            return self.api._get_organization(self.organization_id)
    @organization.setter
    def organization(self, organization):
            if organization:
                self.organization_id = organization.id
    @property
    def updated(self):
        """
        |  Comment: The time the user was last updated
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class UserField(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        
        
        #:| Comment: If true, this field is available for use
        #:| Mandatory: no
        #:| Type: boolean
        #:| Read-only: no
        self.active = None
        
        
        #:| Comment: The time the ticket field was created
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.created_at = None
        
        
        #:| Comment: User-defined description of this field's purpose
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.description = None
        
        
        #:| Comment: Automatically assigned upon creation
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: yes
        self.id = None
        
        
        #:| Comment: A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders.
        #:| Mandatory: on create
        #:| Type: string
        #:| Read-only: no
        self.key = None
        
        
        #:| Comment: Ordering of the field relative to other fields
        #:| Mandatory: no
        #:| Type: integer
        #:| Read-only: no
        self.position = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "description" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_description = None
        
        
        #:| Comment: The dynamic content placeholder, if present, or the "title" value, if not. See Dynamic Content
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.raw_title = None
        
        
        #:| Comment: Regular expression field only. The validation pattern for a field value to be deemed valid.
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: no
        self.regexp_for_validation = None
        
        
        #:| Comment: The title of the custom field
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.title = None
        
        
        #:| Comment: Type of the custom field: "checkbox", "date", "decimal", "dropdown", "integer", "regexp", "text", or "textarea"
        #:| Mandatory: yes
        #:| Type: string
        #:| Read-only: no
        self.type = None
        
        
        #:| Comment: The time of the last update of the ticket field
        #:| Mandatory: no
        #:| Type: date
        #:| Read-only: yes
        self.updated_at = None
        
        
        #:| Comment: The URL for this resource
        #:| Mandatory: no
        #:| Type: string
        #:| Read-only: yes
        self.url = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def created(self):
        """
        |  Comment: The time the ticket field was created
        """
        if self.created_at:
            return dateutil.parser.parse(self.created_at)
    @created.setter
    def created(self, created):
            if created:
                self.created_at = created
    @property
    def updated(self):
        """
        |  Comment: The time of the last update of the ticket field
        """
        if self.updated_at:
            return dateutil.parser.parse(self.updated_at)
    @updated.setter
    def updated(self, updated):
            if updated:
                self.updated_at = updated
    
    
class UserRelated(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self.assigned_tickets = None
        self.ccd_tickets = None
        self.entry_subscriptions = None
        self.forum_subscriptions = None
        self.organization_subscriptions = None
        self.requested_tickets = None
        self.subscriptions = None
        self.topic_comments = None
        self.topics = None
        self.votes = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    
    
class Via(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._source = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def source(self):
        
        if self.api and self._source:
            return self.api._get_source(self._source)
    @source.setter
    def source(self, source):
            if source:
                self._source = source
    
    
class VoiceCommentEvent(BaseObject):
    def __init__(self, api=None, **kwargs):
        self.api = api
        self._attachments = None
        self._data = None
        self.author_id = None
        self.body = None
        self.formatted_from = None
        self.formatted_to = None
        self.html_body = None
        self.id = None
        self.public = None
        self.transcription_visible = None
        self.trusted = None
        self.type = None
        
        for key, value in kwargs.items():
            setattr(self, key, value)

    @property
    def attachments(self):
        
        if self.api and self._attachments:
            return self.api._get_attachments(self._attachments)
    @attachments.setter
    def attachments(self, attachments):
            if attachments:
                self._attachments = attachments
    @property
    def data(self):
        
        if self.api and self._data:
            return self.api._get_data(self._data)
    @data.setter
    def data(self, data):
            if data:
                self._data = data
    @property
    def author(self):
        
        if self.api and self.author_id:
            return self.api._get_user(self.author_id)
    @author.setter
    def author(self, author):
            if author:
                self.author_id = author.id
    
    